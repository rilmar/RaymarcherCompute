// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
uint ResultWidth;
uint ResultHeight;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4 _Time;
float4 _SinTime;
float4 _CosTime;

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction){
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv){
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

struct Shape
{
    int type; // 0 = sphere, 1 = cube;
    float3 origin;
    float3 size;
};


struct Scene {
    Shape A;
    Shape B;
    Shape shapes[10];
    int shapeAtype;
    int shapeBtype;
    int mode; //0 none, 1 merge, 2 cut, 3 clip
};


// struct Sphere
// {
//     float3 origin;
//     float3 radius;
// };

// Sphere CreateSphere(float3 origin, float3 radius){
//     Sphere sphere;
//     sphere.origin = origin;
//     sphere.radius = radius;
//     return sphere;
//}

float sphereSDF(Ray ray, Shape sphere) {
    return length(ray.origin - sphere.origin) - sphere.size.x;

}

float boxSDF(Ray ray, Shape box)
{
    float3 o = abs(ray.origin - box.origin) - box.size;
    float ud = length(max(o,0));
    float n = max(max(min(o.x,0),min(o.y,0)), min(o.z,0));
    return ud+n;
}

Shape createShape(float3 origin, float3 size, int type){

    Shape shape;
    shape.type = type;
    shape.origin = origin;
    shape.size = size;

    return shape;
}

//smooth min function
float smin( float a, float b, float k )
{
    float h = max( k-abs(a-b), 0.0 )/k;
    return min( a, b ) - h*h*k*(1.0/4.0);
}


float DistanceToScene(Ray ray, Scene scene){
    //Sphere s = CreateSphere(float3(1.f, 1.f, 1.f), 0.5f);
    //Box b = createBox(float3(5.0f,0.0f,0.0f),float3(.7f));
    Shape A = scene.A;
    Shape B = scene.B;
    A.origin.x *= 2*_SinTime.z;

    float dA;
    if(A.type == 0){
      dA =  sphereSDF(ray, A);
    }else{
       dA = boxSDF(ray, A);
    }

    float dB;
    if(B.type == 0){
       dB =  sphereSDF(ray, B);
    }else{
       dB = boxSDF(ray, B);
    }


    
   // float sd = DistanceToSphere(repeatRay, s);
   switch (scene.mode){
      case 0: //normal
        return min(dA,dB);
        break;
      
      case 1: //blend
        return smin(dA,dB,1);
        break;

      case 2: //clip
        return max(dA,dB);
        break;

      case 3: //cut shape B
        return max(dA,dB*-1.0);
        break;

      case 4: //cut shape A
        return max(dB,dA*-1.0);
        break;
   }

   return -1;
    
}

Scene setScene(){
    Scene scene;
    
    Shape A = createShape(float3(1.0f, 0.0f, 0.0f), float3(0.6f,0.6f,0.6f), 0);
    Shape B = createShape(float3(0.0f, 0.0f, 0.0f),float3(.5f, .5f, .5f), 1);
    

    scene.A = A;
    scene.B = B;
    scene.mode = 2;

    return scene;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    //Shape A = createShape(float3(1.0f, 0.0f, 0.0f), float3(0.4f,0.4f,0.4f), 0);
    //Shape B = createShape(float3(0.0f, 0.0f, 0.0f),float3(.5f, .5f, .5f), 1);
    Scene scene = setScene();

    uint width, height;
    Result.GetDimensions(width, height);

    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    Ray ray = CreateCameraRay(uv);
    float rayDistance = 0.0f;
    int marchingSteps = 0;

    float maxDistance = 100.0f;
    int maxSteps = 250;
    float epsilon = 0.001f;

    float4 result = float4(ray.direction * 0.5f + 0.5f, 1.0f); // This will be background gradient for now

    while(rayDistance < maxDistance && marchingSteps < maxSteps){
        marchingSteps += 1;
        float sceneDistance = DistanceToScene(ray, scene);

        if(sceneDistance < epsilon){
            result = float4(float(0.1 * marchingSteps), 1.0f, 1.0f, 1.0f);
            break;
        }
        ray.origin += ray.direction * sceneDistance;
        rayDistance += sceneDistance;
    }

    Result[id.xy] = result;

}