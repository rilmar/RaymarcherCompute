// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

const int MAX_MARCH = 255;
const float MAX_DISTANCE = 100.0;
const float  SURFACE_THRESHOLD = .0001;

struct Ray
{
    float3 origin;
    float3 direction;
};

struct Sphere
{
    float3 origin;
    float size;
};

Sphere createSphere(float3 origin, float size)
{
    Sphere sphere;
    sphere.origin = origin;
    sphere.size = size;
    return sphere;
}

//returns a ray struct
Ray createRay(float3 origin, float3 direction){
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray createCameraRay(float2 uv){
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return createRay(origin, direction);
}

float sphereSDF(float3 marchPosition, Sphere sphere) {
    return length(marchPosition - sphere.origin) - sphere.size; 
}

float distanceToScene(float3 marchPosition){
    Sphere s = createSphere(float3(1.0f, 0.0f, 0.0f), 0.7f);
    float sd =sphereSDF(marchPosition, s);
    return sd;
}

float rayMarch(Ray ray) {
	float dO=0.;
    
    for(int i=0; i<MAX_DISTANCE; i++) {
    	float3 marchPosition = ray.origin + ray.direction * dO;
        float dS = distanceToScene(marchPosition);
        dO += dS;
        if(dO>MAX_DISTANCE || dS<SURFACE_THRESHOLD) break;
    }
    
    return dO;
}

RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    //Raymarching Algorithm here
    uint width, height;
    Result.GetDimensions(width, height);
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height));// * 2.0f - 1.0f);
    //set up ray with ray origin and ray direction (x,y position of camera, facing in positive z direction)
    Ray camera = createCameraRay(uv);

    float d = rayMarch(camera);
    float4 result = float4(camera.direction * 0.5f + 0.5f, 1.0f);
    if(d <= SURFACE_THRESHOLD){
        result = float4(float(0.1 * d), 1.0f, 1.0f, 1.0f);
    }
}
